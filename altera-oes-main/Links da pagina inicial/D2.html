<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Saiba o que foi a condenação do candidato a prefeito Pablo Marçal(PRTB) e a sua relação com o vazamento de
        dados</title>

    <!-- Link para o Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet" />

    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-image: url(../img/esttudionot.jpg);
            background-repeat: none;
            background-size:cover;
            background-attachment: fixed;
            background-color: rgba(0, 0, 0, 0.5); /* Cor preta semi-transparente */
            background-blend-mode: darken; 
          margin: 0;
            padding: 0;
            color: #333;
        }

        div {
            max-width: 900px;
            margin: 150px auto;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        h1,
        h2 {
            color: #2e2f31;
            text-align: justify;
            margin-bottom: 20px;
        }

        .text {
            text-align: justify;
            line-height: 1.6;
            color: #555;
        }

        .acessadoepublicado {
            font-family: monospace;
            font-size: 13px;
            color: #888;
            margin-top: -10px;
        }

        img {
            width: 100%;
            height: auto;
            border-radius: 10px;
            margin-top: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        figcaption {
            font-size: 14px;
            color: #777;
            text-align: center;
            margin-top: 10px;
        }

        p,
        h1,
        h2 {
            font-family: 'Roboto', sans-serif;
        }

        a {
            text-decoration: none;
            color: #0077ff;
            transition: 300ms;
        }

        a:hover {
            color: #0056b3;
        }

        nav {
            font-size: 25px;
            position: fixed;
            left: 20px;
            top: 20px;
            background-color: #fff;
            padding: 10px;
            border-radius: 50%;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        nav a {
            color: #333;
        }

        nav a:hover {
            color: #0077ff;
        }

        h3 {
            color: #0077ff;
            margin-top: 30px;
            margin-bottom: 10px;
        }

        hr {
            border: none;
            border-top: 1px solid #ddd;
            margin: 20px 0;
        }

              /* Estilo para a área de comentários */
  .comment-section {
    margin-top: 40px;
    background-color: #f9f9f9;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  }

  .comment-section h2 {
    font-size: 24px;
    color: #2e2f31;
    margin-bottom: 20px;
  }

  .comment-section form {
    display: flex;
    flex-direction: column;
    gap: 15px;
  }

  .comment-section input,
  .comment-section textarea {
    padding: 12px;
    border: 1px solid #ddd;
    border-radius: 8px;
    font-size: 16px;
    transition: all 0.3s ease;
  }

  .comment-section textarea {
    resize: vertical;
    height: 120px;
  }

  /* Efeito ao passar o mouse sobre os campos de input */
  .comment-section input:focus,
  .comment-section textarea:focus {
    border-color: #0077ff;
    box-shadow: 0 0 5px rgba(0, 119, 255, 0.3);
  }

  /* Estilizando o botão de envio de comentário */
  .comment-section button {
    padding: 12px 20px;
    background-color: #0077ff;
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.2s ease;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }

  /* Efeito ao passar o mouse sobre o botão */
  .comment-section button:hover {
    background-color: #0056b3;
    transform: translateY(-2px);
  }

  .comment-section button:active {
    transform: translateY(1px);
  }

  /* Estilo para os comentários */
  .comment-list {
    margin-top: 20px;
  }

  .comment-item {
    background-color: #fff;
    padding: 15px;
    margin-bottom: 10px;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  }

  .comment-item strong {
    color: #0077ff;
    font-size: 16px;
  }

  .comment-item p {
    color: #333;
    margin: 5px 0;
    font-size: 14px;
  }

  .comment-item .timestamp {
    font-size: 12px;
    color: #888;
  }
    </style>
</head>

<body>
    
    <h1>NOTICIAS</h1>

    <nav>
        <a href="../pagina Noticias/cards.html"><i class="fa-solid fa-arrow-left"></i></a>
    </nav>

    <script src="https://kit.fontawesome.com/2572ff7e65.js" crossorigin="anonymous"></script>
    <div>
        <h1>
            Ciberataques com ransomware visam empresas estrangeiras.
        </h1>

        <p>
            Um grupo de cibercriminosos, conhecido como Crypt Ghouls, foi identificado como responsável por uma série de ataques direcionados a empresas…
        </p>

        <img src="../img/noticia2.jpg" />
        <figcaption>Bandeira do reino Unido</figcaption>

        <p class="text">Por <b>Aline Victoria</b>, Life Encryption</p>

        <p class="acessadoepublicado">
            Publicado em 01/10/2024 e atualizado às 13:58
        </p>
        <hr />

        <p class="text">
            Um grupo de cibercriminosos, conhecido como Crypt Ghouls, foi identificado como responsável por uma série de ataques direcionados a empresas e agências governamentais russas, utilizando ransomware com o objetivo de interromper operações e obter ganhos financeiros. Segundo a Kaspersky, o grupo emprega um conjunto de ferramentas que inclui Mimikatz, XenAllPasswordPro, PingCastle, Localtonet, resocks, AnyDesk e PsExec, entre outros. Como carga final, eles utilizam os conhecidos ransomwares LockBit 3.0 e Babuk. As vítimas desses ataques incluem agências governamentais e empresas dos setores de mineração, energia, finanças e varejo na Rússia.
        </p>

        <p class="text">
            Em dois casos investigados pela Kaspersky, o vetor inicial de intrusão foi identificado como o uso das credenciais de login de um prestador de serviços para se conectar aos sistemas internos via VPN. Essas conexões VPN partiram de endereços IP associados a uma rede de um provedor de hospedagem russo e à rede de um contratante, sugerindo que os atacantes tentam passar despercebidos ao explorar relacionamentos confiáveis. Acredita-se que as redes de prestadores de serviços foram comprometidas por meio de falhas de segurança não corrigidas ou serviços de VPN vulneráveis.
        </p>

        <p class="text">
            Os ataques terminam com a criptografia dos dados do sistema usando versões públicas do LockBit 3.0 para Windows e Babuk para Linux/ESXi, além de criptografar dados na Lixeira para impedir a recuperação dos arquivos. Uma nota de resgate é deixada, com um link contendo o ID do grupo no serviço de mensagens Session para contato futuro. Para criptografar as máquinas virtuais, os atacantes se conectam ao servidor ESXi via SSH, carregam o Babuk e iniciam o processo de criptografia. Segundo a Kaspersky, o compartilhamento de ferramentas e conhecimento entre esses grupos torna difícil identificar os responsáveis específicos por essa onda de ataques, sugerindo uma colaboração contínua entre os atores maliciosos e dificultando ainda mais a atribuição dos ataques.
        </p>

        



    </div>
    <div class="comment-section">
        <h2>Comentários</h2>
        <form id="comment-form">
          <textarea id="comment-content" placeholder="Digite seu comentário"></textarea>
          <button type="submit">Comentar</button>
        </form>
        <div class="comment-list" id="comments-list"></div>
      </div>
      <script>
        // Função para verificar se o usuário está autenticado
        function checkAuth() {
          const token = localStorage.getItem('token');
          if (!token) {
            alert('Você precisa estar autenticado para comentar.');
            window.location.href = '/login'; // Redireciona para a página de login, caso necessário
          }
        }
      
        // Função para enviar o comentário
        async function submitComment(event) {
          event.preventDefault();
          const content = document.getElementById('comment-content').value;
          const token = localStorage.getItem('token');
      
          if (!content) {
            alert("O comentário não pode estar vazio.");
            return;
          }
      
          try {
            const response = await fetch('http://localhost:3000/api/comments', { // Corrigido o endpoint
              method: 'POST',
              headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`  // Enviar token JWT
              },
              body: JSON.stringify({ content })
            });
      
            if (response.ok) {
              fetchComments(); // Recarregar os comentários após um novo envio
            } else {
              alert('Erro ao enviar comentário');
            }
          } catch (error) {
            console.error('Erro ao comentar:', error);
          }
        }
      
        // Função para buscar e exibir os comentários
        async function fetchComments() {
          const token = localStorage.getItem('token');
          try {
            const response = await fetch('http://localhost:3000/api/comments', {
              method: 'GET',
              headers: { 'Authorization': `Bearer ${token}` } // Enviar token JWT
            });
      
            if (!response.ok) {
              throw new Error('Falha ao buscar os comentários');
            }
      
            const data = await response.json();
            const commentsList = document.getElementById('comments-list');
            commentsList.innerHTML = ''; // Limpar os comentários anteriores
      
            data.comments.forEach(comment => {
              const commentDiv = document.createElement('div');
              commentDiv.classList.add('comment-item');
              const date = new Date(comment.createdAt);
              commentDiv.innerHTML = `
                <strong>${comment.user.email}</strong>
                <p>${comment.content}</p>
                <p class="timestamp">${date.toLocaleString()}</p>
              `;
              commentsList.appendChild(commentDiv);
            });
          } catch (error) {
            console.error('Erro ao buscar comentários:', error);
          }
        }
      
        // Verifica se o usuário está autenticado ao carregar a página
        checkAuth();
        fetchComments(); // Carregar os comentários quando a página for aberta
      
        // Adicionando evento de envio do comentário
        document.getElementById('comment-form').addEventListener('submit', submitComment);
      </script>

</body>

</html>